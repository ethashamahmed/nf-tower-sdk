"""
Module contains Nextflow Tower API client.

The client is using an autogenerated API client SDK.
The SDK library was generated
using https://github.com/openapi-generators/openapi-python-client
and the NFT OpenAPI schema
at https://tower.nf/openapi/nextflow-tower-api-latest.yml
"""
import json
from typing import Union

from jsonschema import validate, ValidationError
from httpx._exceptions import ReadTimeout

from nf_tower_sdk.nft.api_library import AuthenticatedClient
from nf_tower_sdk.nft.api_library.api.default import (
    list_organizations,
    list_workspaces,
    describe_workflow_launch,
    create_workflow_launch,
    describe_pipeline_launch,
    list_pipelines,
    list_compute_envs,
    describe_pipeline_schema,
)
from nf_tower_sdk.nft.api_library.models import (
    ErrorResponse,
    Launch,
    ListComputeEnvsResponse,
    ListPipelinesResponse,
    ListOrganizationsResponse,
    ListWorkspacesResponse,
    SubmitWorkflowLaunchRequest,
    WorkflowLaunchResponse,
)


class NextflowTowerClientError(Exception):
    """Exception raised when Nextflow Tower API client returns error response."""


class NextflowTowerClient:
    """
    Client for consuming Nextflow Tower API.
    Uses autogenerated SDK based on Tower API Schema.
    """

    _client: AuthenticatedClient
    _url: str
    org_name: str
    org_id: int
    workspace_name: str
    workspace_id: int

    # pylint: disable=too-many-arguments
    def __init__(
        self,
        url: str,
        api_token: str,
        org_name: str,
        workspace_name: str,
        timeout: int = 20.0,
    ) -> None:
        self._url = url
        self._client = AuthenticatedClient(
            base_url=f"{url}/api", token=api_token, timeout=timeout
        )
        self.org_name: str = org_name
        self.workspace_name = workspace_name
        self.org_id = self.get_org_id(org_name)
        self.workspace_id = self.get_workspace_id(
            self.org_id, workspace_name
        )

    @property
    def tower_workflow_run_base_url(self) -> str:
        """Returns the base url for workflow runs in Tower."""
        return f"{self._url}/orgs/{self.org_name}/workspaces/{self.workspace_name}/watch"

    def is_valid_pipeline_params(
        self, pipeline_id: int, params: dict
    ) -> Union[bool, NextflowTowerClientError]:
        """
        Validates pipeline params using schema
        retrieved from the pipeline in Tower

        :param pipeline_id: Pipeline numeric identifier
        :param params: Dictionary containing pipeline parameters

        :return: True if parameters are valid.
        """
        params_schema = self.get_pipeline_params_schema(pipeline_id)
        try:
            validate(instance=params, schema=json.loads(params_schema))
        except ValidationError as err:
            raise NextflowTowerClientError from err
        return True

    def get_compute_env_id(
        self, compute_env_name: str
    ) -> Union[str, NextflowTowerClientError]:
        """
        Return compute env ID using compute env name. Exact name must be given.

        :param compute_env_name: Exact name of compute environment in Tower.

        :return: Compute environment ID.
        """
        compute_envs = list_compute_envs.sync(
            client=self._client,
            workspace_id=self.workspace_id,
            status="AVAILABLE",
        )
        if isinstance(compute_envs, ListComputeEnvsResponse):
            for compute_env in compute_envs.compute_envs:
                if compute_env.name.lower() == compute_env_name.lower():
                    return str(compute_env.id)

        raise NextflowTowerClientError(
            f"Failed to find compute env: {compute_env_name}. Response from tower: {compute_envs}"
        )

    def get_org_id(
        self, org_name: str
    ) -> Union[int, NextflowTowerClientError]:
        """
        Returns organisation ID based on name.

        :param org_name: Name of organisation
        """
        list_org_response = list_organizations.sync(client=self._client)
        if isinstance(list_org_response, ListOrganizationsResponse):
            for org in list_org_response.organizations:
                if org.name.lower() == org_name.lower():
                    return org.org_id
        raise NextflowTowerClientError(
            f"Tower organisation {org_name} doesn't exist."
        )

    def get_pipeline_id(
        self, pipeline_name: str
    ) -> Union[int, NextflowTowerClientError]:
        """
        Returns pipeline id using pipeline_name.

        Every pipeline has a distinct name so searching using the
        exact name should only return one pipeline. If it fails
        to find the pipeline or gets error response from Tower
        a NextflowTowerClientError is raised

        :param pipeline_name: Exact name of the pipeline

        :return: Pipeline ID
        """
        pipeline_list_response = list_pipelines.sync(
            client=self._client,
            workspace_id=self.workspace_id,
            search=pipeline_name,
        )
        if isinstance(pipeline_list_response, ListPipelinesResponse):
            for pipeline in pipeline_list_response.pipelines:
                if pipeline.name.lower() == pipeline_name.lower():
                    return pipeline.pipeline_id
        raise NextflowTowerClientError(
            f"Failed to find pipeline: {pipeline_name}, "
            f"Response from Tower: {pipeline_list_response}"
        )

    def get_pipeline_launch(
        self, pipeline_id: int
    ) -> Union[Launch, NextflowTowerClientError]:
        """
        Returns a pipeline launch for the given pipeline ID.
        Raises NextflowTowerClientError if no matching pipeline launch
        is found in Tower

        :param pipeline_id: Pipeline numeric identifier

        :return: a Pipeline Launch object
        """
        pipeline = describe_pipeline_launch.sync(
            client=self._client,
            workspace_id=self.workspace_id,
            pipeline_id=pipeline_id,
        )
        if isinstance(pipeline, (ErrorResponse, type(None))):
            raise NextflowTowerClientError(
                f"Failed to find a pipeline launch in Tower for pipeline_id: {pipeline_id}. "
                f"Response from tower: {pipeline}"
            )
        return pipeline.launch

    def get_pipeline_params_schema(
        self, pipeline_id: int
    ) -> Union[str, NextflowTowerClientError]:
        """
        Returns the schema defined for the pipelines input parameters.

        :param pipeline_id: Pipeline numeric identifier
        """
        get_schema_response = describe_pipeline_schema.sync(
            client=self._client,
            workspace_id=self.workspace_id,
            pipeline_id=pipeline_id,
        )
        if isinstance(get_schema_response, (ErrorResponse, type(None))):
            raise NextflowTowerClientError(
                f"Failed to get pipeline parameters schema. Error: {get_schema_response}"
            )
        return get_schema_response.schema

    def get_workspace_id(
        self, org_id: int, workspace_name: str
    ) -> Union[int, NextflowTowerClientError]:
        """
        Returns the ID in Nextflow Tower for a given workspace name.
        Raises NextflowTowerClientError if no matching workspace found in Tower.

        :param org_id: Organisation ID the workspace belongs to.
        :workspace_name: Name of the workspace.

        :return: Workspace ID
        """
        workspaces_response = list_workspaces.sync(
            client=self._client, org_id=org_id
        )
        if isinstance(workspaces_response, ListWorkspacesResponse):
            for workspace in workspaces_response.workspaces:
                if workspace.name == workspace_name:
                    return workspace.id
        raise NextflowTowerClientError(
            f"Tower Workspace {workspace_name} doesn't exist."
        )

    def get_workflow_launch(
        self, workflow_id: str
    ) -> Union[WorkflowLaunchResponse, NextflowTowerClientError]:
        """
        Describes a workflow launch for the given ID

        :param workflow_id: Workflow string identifier
        :return: Workflow description
        """
        workflow = describe_workflow_launch.sync(
            client=self._client,
            workspace_id=self.workspace_id,
            workflow_id=workflow_id,
        )
        if isinstance(workflow, (ErrorResponse, type(None))):
            raise NextflowTowerClientError(
                f"Failed to find a workflow launch in Tower for workflow_id: {workflow_id}. "
                f"Response from tower: {workflow}"
            )
        return workflow.launch

    def launch_workflow(
        self, request: Launch
    ) -> Union[str, NextflowTowerClientError]:
        """
        Launches a new workflow and returns the workflow ID.
        Raises NextflowTowerClientError if Tower returns error
        when launching workflow

        :param launch_request: a WorkflowLaunchRequest object

        :return: new workflow run ID
        """
        try:
            submit_workflow_response = create_workflow_launch.sync(
                client=self._client,
                workspace_id=self.workspace_id,
                json_body=SubmitWorkflowLaunchRequest(launch=request),
            )
        except ReadTimeout as err:
            raise NextflowTowerClientError(
                f"Tower API call timeout when launching pipeline: {request.pipeline}. "
                f"NOTE: Workflow might have launched before read timeout."
            ) from err

        if isinstance(submit_workflow_response, ErrorResponse):
            raise NextflowTowerClientError(
                f"Failed to launch pipeline: {request.pipeline}, "
                f"error: {submit_workflow_response}"
            )
        return submit_workflow_response.workflow_id
